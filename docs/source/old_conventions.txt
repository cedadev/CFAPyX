An aggregation variable is a variable which has been formed by combining (i.e. aggregating) multiple fragments that are generally stored in fragment datasets that are external to the file containing the aggregation variable, i.e. the aggregation file. A fragment is an array of data with sufficient metadata for it to be correctly interpreted in the context of the aggregation, as described by Section 2.8.2 "Fragment Interpretation". The aggregation variable does not contain any actual data, instead it contains instructions on how to create its aggregated data in memory as an aggregation of the data from each fragment.
Aggregation provides the utility of being able to view, as a single entity, a dataset that has been partitioned across multiple other datasets, whilst taking up very little extra space on disk (since the aggregation file contains no copies of the data in the fragments). Fragment datasets may be CF-compliant or have any other format, thereby allowing an aggregation variable to act as a CF-compliant view of non-CF datasets. Use cases for storing aggregations include, but are not limited to: data analysis, as it avoids the computational expense of deriving the aggregation at the time of analysis; archive curation, as the aggregation can act as a metadata-rich archive index; and model simulations, for combining output data that have been written to disk as multiple datasets decomposed in time and space.
An aggregation variable must be a scalar (i.e. it has no dimensions). It acts as a container for all of the usual attributes that describe the data, with the addition of two special attributes: one that defines the aggregated dimensions, i.e. the dimensions of the aggregated data; and one that provides the instructions on how the aggregated data is to be created. The data type of the aggregation variable must be the data type of the aggregated data, but the value of the aggregation variable’s single element is immaterial.
Aggregation variables may be used as any kind of variable (data variable, coordinate variable, cell measures variable, etc.), but it is recommended that container variables whose data are immaterial (such as grid mapping variables) are not encoded as aggregation variables.
Any text applying to a variable in the CF conventions applies in exactly the same way to an aggregation variable in the same role; and any reference to the dimensions or data of a variable applies to the aggregated dimensions or aggregated data, respectively, of an aggregation variable. For instance:
* The dimension of a coordinate variable of an aggregation data variable must be one of the aggregated dimensions of the aggregation data variable.
* The name of an aggregation coordinate variable (which is a scalar) must be the same as the name of its single aggregated dimension (identified by its aggregated_dimensions attribute), just as the name of a coordinate variable (which is one-dimensional) must be the same as the name of its single dimension.
The details of how to encode and decode aggregation variables are given in this section, with examples provided in Appendix L, Aggregation Variable Examples.

2.8.1. Aggregated Dimensions and Data
The aggregated dimensions are stored with the aggregation variable’s aggregated_dimensions attribute, and it is the presence of this attribute that identifies the variable as an aggregation variable. The value of the aggregated_dimensions attribute is a blank-separated list of the aggregated dimension names given in the order which matches the dimensions of the aggregated data. If the aggregated data is scalar then there are no aggregated dimensions and the aggregated_dimensions attribute must be an empty string. The aggregated dimensions must exist as dimensions in the aggregation file.
The fragments which provide the aggregated data are conceptually organised into a fragment array that has the same number of dimensions as the aggregated data. Each dimension of the fragment array is called a fragment array dimension, and corresponds to the aggregated dimension with the same position in the aggregated data. The size of a fragment array dimension is equal to the number of fragments that are needed to span its corresponding aggregated dimension. See A schematic representation of a fragment array for aggregated data.
The aggregated data are created by concatenating the canonical forms of the fragments' data (see Section 2.8.2 "Fragment Interpretation") along each fragment array dimension, and in the order in which they appear in the fragment array.
Example 2.2. A schematic representation of a fragment array for aggregated data
Fragment array position [0, 0, 0]
Fragment location: file_A.ncFragment data shape: (17, 91, 180)17 vertical levels[90, 0] degrees north[0, 180) degrees east	Fragment array position [0, 0, 1]
Fragment location: file_B.ncFragment data shape: (17, 91, 180)17 vertical levels[90, 0] degrees north[180, 360) degrees east
Fragment array position [0, 1, 0]
Fragment location: file_C.ncFragment data shape: (17, 45, 180)17 vertical levels(0, -45] degrees north[0, 180) degrees east	Fragment array position [0, 1, 1]
Fragment location: file_D.ncFragment data shape: (17, 45, 180)17 vertical levels(0, -45] degrees north[180, 360) degrees east
Fragment array position [0, 2, 0]
Fragment location: file_E.ncFragment data shape: (17, 45, 180)17 vertical levels(-45, -90] degrees north[0, 180) degrees east	Fragment array position [0, 2, 1]
Fragment location: file_F.ncFragment data shape: (17, 45, 180)17 vertical levels(-45, -90] degrees north[180, 360) degrees east
The fragments, stored in six fragment datasets, are arranged in a three-dimensional fragment array with shape (1, 3, 2). Each fragment spans the entirety of the Z dimension, but only a part of the Y-X plane, which has 1 degree resolution. The fragments combine to create three-dimensional aggregated data that have global Z-Y-X coverage, with shape (17, 181, 360). The Z aggregated dimension is spanned by one fragment, the Y aggregated dimension is spanned by three fragments, and the X aggregated dimension is spanned by two fragments. Note that, since this example is a schematic representation, the C or Fortran order of the dimensions is of no consequence. See Aggregation variable example 4 for a CDL representation of this fragment array.
The fragment array must be defined by an aggregation variable’s aggregated_data attribute. This attribute takes a string value comprising blank-separated elements of the form "feature: variable", where feature is a case-sensitive keyword that identifies a feature of the fragment array, and variable is a fragment array variable which provides values for that feature. The features and their values unambiguously define the fragment array. The order of elements in the aggregated_data attribute is not significant.
The features must comprise either all three of the shape, location, and address keywords; or else both of the shape and value keywords. No other combinations of keywords are allowed. These features are defined as follows:

shape
The integer-valued shape fragment array variable defines the shape of each fragment’s data in its canonical form (see Section 2.8.2 "Fragment Interpretation"). In general, the shape fragment array variable is two-dimensional, with the size of the slower-varying dimension (i.e. the first dimension in CDL order, representing rows) being the number of fragment array dimensions, and the size of the more rapidly-varying dimension (i.e. the second dimension in CDL order, representing columns) being the size of the largest fragment array dimension. The rows correspond to the fragment array dimensions in the same order, and each row provides the sizes of the fragments along its corresponding dimension of the fragment array, padded with missing values if there are fewer fragments than the number of columns. The sum of non-missing values in a row must therefore equal the size of the corresponding aggregated dimension. See Aggregation variable example 4, which shows the shape fragment array variable for the fragment array described by A schematic representation of a fragment array for aggregated data. If the aggregated data is scalar then the shape fragment array variable must be a scalar and contain the value 1. See Aggregation variable example 8.

location
The string-valued location fragment array variable defines the locations of fragment datasets. In general its dimensions correspond to, and have the same sizes as, the fragment array dimensions in the same order as they appear in the conceptual fragment array. A fragment dataset is located with a Uniform Resource Identifier (URI) [URI] that must be either an absolute URI (a URI that begins with a scheme component followed by a : character, such as file://data/file.nc, https://remote.host/data/file.nc, s3://remote.host/data/file.nc, or locally_meaningful_protocol://UID), or else a relative-path URI reference (a URI that is not an absolute URI and which does not begin with a / or # character, such as file.nc, ../file.nc, or data/file.nc). A relative-path URI reference is taken as being relative to the location of the aggregation file. If the aggregation file is moved to another location, then a fragment dataset identified by an absolute URI will still be accessible, whereas a fragment dataset identified by a relative-path URI reference will also need be moved to preserve the relative reference. Not all fragment dataset locations need be of the same URI type. See Aggregation variable example 1 and Aggregation variable example 2.
The location fragment array variable may have an extra trailing dimension that allows multiple versions of fragments to be specified. Each version must contain equivalent information, so that any version that exists may be selected for use in the aggregated data. This could be useful when it is known that a fragment could be stored in a number of locations, but it is not known which of them might exist at any given time. For instance, when remotely stored and locally cached versions of the same fragment have been defined, an application program could choose to only retrieve the remote version if the local version does not exist. Every fragment must have at least one version, but not all fragments need to have the same number of versions. Where fragments have fewer versions than others, the trailing dimension must be padded with missing values. See Aggregation variable example 2.
A fragment dataset location may be defined with any number of string substitutions, each of which is provided by the location fragment array variable’s substitutions attribute. The substitutions attribute takes a string value comprising blank-separated elements of the form "substitution: replacement", where substitution is a case-sensitive keyword that defines part of a location fragment array variable value which is to be replaced by replacement in order to find the actual fragment dataset location. A location fragment array variable value may include any subset of zero or more of the substitution keywords. After replacements have been made, the fragment dataset location must be an absolute URI or a relative-path URI reference. The substitution keyword must have the form ${*}, where * represents any number of any characters. For instance, the fragment dataset location https://remote.host/data/file.nc could be stored as ${path}file.nc, in conjunction with substitutions="${path}: https://remote.host/data/". The order of elements in the substitutions attribute is not significant, and the substitutions for a given fragment must be such that applying them in any order will result in the same fragment dataset location. The use of substitutions can save space in the aggregation file; and in the event that the fragment locations need to be updated after the aggregation file has been created, it may be possible to achieve this by modifying the substitutions attribute rather than by changing the actual location fragment array variable values. See Aggregation variable example 3.

address
The address fragment array variable, that may have any data type, defines how to find each fragment within its fragment dataset, i.e. the address of the fragment. In general it has the same dimensions in the same order as the location fragment array variable, and must contain a non-missing value corresponding to each fragment version. However, if the address fragment array variable is a scalar, then its single value applies to all versions of all fragments. For a netCDF fragment dataset, the address must be the string-valued netCDF variable name of the fragment. Addresses for other fragment dataset formats are allowed, on the understanding that an application program may choose to ignore any values that it does not understand. See Aggregation variable example 1 and Aggregation variable example 6.

value
When the data values within a fragment are all the same, for each fragment, the value fragment array variable allows each fragment to be represented explicitly by its unique data value, rather than by reference to a fragment dataset. The value fragment array variable dimensions correspond to, and have the same sizes as, the fragment array dimensions in the same order as they appear in the conceptual fragment array. The value fragment array variable may have any data type, and contains each fragment’s unique value. A fragment that contains wholly missing data is specified by any missing value indicated by the aggregation variable. See Aggregation variable example 7, which uses an aggregation ancillary variable to make fragment dataset attributes available to an aggregation data variable.

2.8.2. Fragment Interpretation
The data of a fragment must be converted to its canonical form prior to being inserted into the aggregated data. The canonical form of a fragment’s data is such that:
* The fragment’s data, in its entirety, provide the values for a unique and contiguous part of the aggregated data.
* The fragment’s data dimensions correspond to the aggregated dimensions in the same order.
* The fragment’s data have the same units as the aggregation variable.
* The fragment’s data have missing values as indicated by the aggregation variable.
* The fragment’s data are not packed (i.e. not stored using a smaller data type than the original data).
* The fragment’s data have the same data type as the aggregation variable.
The conversion of the fragment’s data to its canonical form is carried out by the application program which is creating the aggregated data in memory. For fragment datasets, the application program may ignore any fragment metadata that are not needed for the conversion to the canonical form, as well as any other variables that might exist in the fragment dataset. A combination of the following operations may be required to convert the fragment’s data to its canonical form:
* If, and only if, the fragment’s data has been explicitly defined by its unique value (as opposed to being defined by a fragment dataset), broadcasting that value across the shape of the canonical form of the fragment’s data.
* Inserting missing size 1 dimensions into the fragment’s data (e.g. as required when aggregating two-dimensional fragments into three-dimensional aggregated data).
* Transforming the fragment’s data to have the same data type as the aggregated data. Note that some transformations may result in a loss of information, such as could be the case when casting floating point numbers to integers.
* Transforming missing values in the fragment’s data to a value indicated as missing by the aggregation variable. Note that it is the responsibility of the creator of the aggregation file to ensure that all non-missing fragment data values do not coincide with any of the missing values indicated by the aggregation variable.
* Transforming the fragment’s data to have the aggregation variable’s units (e.g. as required when aggregating time fragments whose units have different reference date/times).
* Unpacking the fragment’s data. Note that if the aggregation variable indicates that the aggregated data values are packed (as determined by the attributes defined in Section 8.1, "Packed Data"), then the canonical fragment data values will represent packed values in the aggregated data, and so will be subject to the aggregation variable’s unpacking.
